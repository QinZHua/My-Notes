数组的扩展
===

数组的扩展
---

扩展运算符（spread）是三个点（...）  
它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列   
扩展运算符后面是一个空数组，则不产生任何效果  
只有函数调用时，扩展运算符才可以放在圆括号中  

由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了  

**扩展运算符的应用：**  
1. 复制数组  
2. 合并数组  
3. 与解构赋值结合  
4. 将字符串转为真正的数组  
5. 实现了 Iterator 接口的对象  
6. Map 和 Set 结构，Generator 函数  


Array.from()
---

Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）  
只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组  
字符串和 Set 结构都具有 Iterator 接口，可以被Array.from转为真正的数组   
参数是一个真正的数组，Array.from会返回一个一模一样的新数组  
扩展运算符（...）也可以将某些数据结构转为数组  
	扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换  
Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组  


Array.of()
---

Array.of()方法用于将一组值，转换为数组  
只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组  
参数只有一个正整数时，实际上是指定数组的长度  
Array.of()总是返回参数值组成的数组。如果没有参数，就返回一个空数组  


数组实例的 copyWithin()
---

copyWithin()方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组  
copyWithin()方法接受三个参数：
1. target（必需）：从该位置开始替换数据。如果为负值，表示倒数  
2. start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算  
3. end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算  
三个参数都应该是数值，如果不是，会自动转为数值  


数组实例的 find() 和 findIndex()
---

数组实例的find方法，用于找出第一个符合条件的数组成员  
它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined  
find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组  
```js
[8, 3, 11, 15].find(function(value, index, arr) {
  return value > 9;
}) // 11
```
数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1  


数组实例的 fill()  
---

fill方法使用给定值，填充一个数组  
fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去  
fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置  
如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象  


数组实例的 entries()，keys() 和 values() 
---

ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组  
唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历  


数组实例的 includes()
---

Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法  
第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始  

**Map 和 Set 数据结构有一个has方法，需要注意与includes区分:**  
* Map 结构的has方法，是用来查找键名的  
* Set 结构的has方法，是用来查找值的  


数组实例的 flat()，flatMap() 
---

数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响  
flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1  
如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数  
如果原数组有空位，flat()方法会跳过空位  

flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组  
flatMap()只能展开一层数组  
flatMap()方法的参数是一个遍历函数，该函数可以接受三个参数，分别是当前数组成员、当前数组成员的位置（从零开始）、原数组  


数组的空位
---

数组的空位指，数组的某一个位置没有任何值  
空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点  
ES6 明确将空位转为undefined  

Array.prototype.sort() 的排序稳定性
---

排序稳定性（stable sorting）是排序算法的重要属性，指的是排序关键字相同的项目，排序前后的顺序不变  
ES2019 明确规定，Array.prototype.sort()的默认排序算法必须稳定  


