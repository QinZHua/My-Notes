正则的扩展
===

RegExp 构造函数
---

在 ES5 中，RegExp构造函数的参数有两种情况  
第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）  
第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝  
ES5 不允许此时使用第二个参数添加修饰符，否则会报错  
ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符  


字符串的正则方法
---

ES6 出现之前，字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()    
ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上   
* String.prototype.match 调用 RegExp.prototype[Symbol.match]  
* String.prototype.replace 调用 RegExp.prototype[Symbol.replace]  
* String.prototype.search 调用 RegExp.prototype[Symbol.search]  
* String.prototype.split 调用 RegExp.prototype[Symbol.split]  


u 修饰符
---

ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码  
一旦加上u修饰符号，就会修改下面这些正则表达式的行为：
**点字符**：点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符  
**Unicode 字符表示法**：ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词  
**量词**：使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符  
**预定义模式**：u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符  
**i 修饰符**：有些 Unicode 字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K  
**转义**：没有u修饰符的情况下，正则中没有定义的转义（如逗号的转义\,）无效，而在u模式会报错  


RegExp.prototype.unicode 属性
---

正则实例对象新增unicode属性，表示是否设置了u修饰符  


y 修饰符
---

ES6 还为正则表达式添加了`y`修饰符，叫做“粘连”（sticky）修饰符   
`y`修饰符的作用与g修饰符类似，也是全局匹配后一次匹配都从上一次匹配成功的下一个位置开始,不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义  
`y`修饰符同样遵守`lastIndex`属性，但是要求必须在`lastIndex`指定的位置发现匹配  
实际上，y修饰符号隐含了头部匹配的标志`^`   
`y`修饰符的一个应用，是从字符串提取 `token`（词元），`y`修饰符确保了匹配之间不会有漏掉的字符  
`g`修饰符会忽略非法字符，而`y`修饰符不会，这样就很容易发现错误  


RegExp.prototype.sticky 属性
---

与y修饰符相匹配，ES6 的正则实例对象多了`sticky`属性，表示是否设置了y修饰符  



RegExp.prototype.flags 属性
---

ES6 为正则表达式新增了`flags`属性，会返回正则表达式的修饰符  


s 修饰符：dotAll 模式
---

正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）  
终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”:  
* U+000A 换行符（\n）  
* U+000D 回车符（\r）  
* U+2028 行分隔符（line separator）  
* U+2029 段分隔符（paragraph separator）  


后行断言 
---

JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言  
“先行断言”指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。“先行否定断言”指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/  
“后行断言”正好与“先行断言”相反  


Unicode 属性类
---

ES2018 引入了一种新的类的写法\p{...}和\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符   


正则匹配索引 
---

正则匹配结果的开始位置和结束位置，目前获取并不是很方便。正则实例的exec()方法，返回结果有一个index属性，可以获取整个匹配结果的开始位置，但是如果包含组匹配，每个组匹配的开始位置，很难拿到  
现在有一个第三阶段提案，为exec()方法的返回结果加上indices属性，在这个属性上面可以拿到匹配的开始位置和结束位置  



String.prototype.matchAll()
---


ES2020 增加了String.prototype.matchAll()方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组   



具名组匹配
---
ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用   
正则表达式使用圆括号进行组匹配  

