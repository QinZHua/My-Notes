1.Let和const命令
===

let命令  
---  

let命令，用来声明变量，声明的变量只在代码块内有效    
例子：  
```js
{
  let a = 10;
  var b = 1;
}
a  //报错
b  //1
```

let命令不存在变量提升  
var命令有变量提升，即在变量声明之前使用，值为undefined  

暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。
暂时性死区会使typeof在变量声明之前报错  

let不允许重复声明同一个变量  
let有块级作用域  
  
ES5 规定，函数只能在顶层作用域和函数作用域之中声明  
例子：  
```js
if (true) {
  function f() {}
}
try {
  function f() {}
} catch(e) {
  // ...
}
//ES5 上面两种函数声明是错的。
```
**ES6 引入了块级作用域**，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。
ES6 的块级作用域必须有大括号   
尽量避免在块级作用域内声明函数，浏览器不一定支持   

const命令
---

const声明一个只读的常量。一旦声明，常量的值就不能改变  
例子：  
```js
const a=3;
a=4//报错
```
const一旦声明变量，就必须立即初始化，不能留到以后赋值  
const的作用域与let命令相同：只在声明所在的块级作用域内有效  
const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用  

**const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动，对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了**
例子：  
```js
//对象
const a={}；
a.aa=111;//成功
a.bb=222;//成功
a={c:'2'};//报错
//数组
const a=[];
a.push(12);//成功
a=[33];//报错
```

ES6声明变量的六种方法：
> var命令(来自ES5)  
> function命令(来自ES5)  
> let命令    
> const命令  
> import命令  
> class命令  

2.变量的解构赋值  
===

ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）  

数组的解构赋值
---
例子：
```js
let [a, b, c] = [1, 2, 3];//a=1,b=2,c=3
let [x,...y]=[1,2,3]；//x=1,y=[2,3]
//从数组中提取值，按照对应位置，对变量赋值
//本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值  
//解构不成功，变量的值就等于undefined
//不完全解构，也可以成功
```

如果等号的右边不是数组，严格地说，是不可遍历的结构，那么将会报错  
对于 Set 结构，也可以使用数组的解构赋值  
例子：  
```js
let [x, y, z] = new Set(['a', 'b', 'c']);
x // "a"
```

事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值  

解构赋值允许指定默认值  
例子：  
```js
let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
```

ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效  
如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined  
例子：  
```js
let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null
```

默认值可以引用解构赋值的其他变量，但该变量必须已经声明  
例子：  
```js
let [x = 1, y = x] = [];     // x=1; y=1
let [x = 1, y = x] = [2];    // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = [];     // 报错
```

对象的解构赋值 
---

例子：  
```js
let {a , b , c}={a : 1,b : 2};//a:1 b:2 c:undefined
//解构失败，变量的值等于undefined
```

对象的解构与数组的解构不同之初：  
数组的元素是按次序排列的，变量的取值由它的位置决定   
而对象的属性没有次序，**变量必须与属性同名**，才能取到正确的值  

变量名与属性名不一致的解构写法：  
例子：  
```js
let {a : hong}={a : 1, b : 2};//hong:1
//实际上的解构
let {a : a , b : b , c : c}={a : 1 , b : 2};//a:1 b:2 c:undefined
```
**对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者**
解构可以用于嵌套结构的对象   
例子：  
```js
let {a : { b }}={a : {b : 1}};//b:1
//a是模式，不是变量
```
解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错  
例子：  
```js
let {foo: {bar}} = {baz: 'baz'};
//foo此时等于undefined，再取子属性就会报错
```

对象的解构赋值可以取到继承的属性  
例子：  
```js
const obj1 = {};
const obj2 = { foo: 'bar' };
Object.setPrototypeOf(obj1, obj2);
const { foo } = obj1;
foo // "bar"
//对象obj1的原型对象是obj2。foo属性不是obj1自身的属性，而是继承自obj2的属性，解构赋值可以取到这个属性  
```

对象的解构也可以指定默认值  
例子：  
```js
var {x = 3} = {};//x=3
var {x, y = 5} = {x: 1};//x=1 y=5
var {x: y = 3} = {};//y=3
var {x: y = 3} = {x: 5};//y=5
var { message: msg = 'Something went wrong' } = {};//"Something went wrong"
```

默认值生效的条件是，对象的属性值严格等于undefined  
例子：  
```js
var {x = 3} = {x: undefined};
x // 3
var {x = 3} = {x: null};
x // null
//null与undefined不严格相等
```

字符串的解构赋值
---
例子：  
```js
const [a, b, c, d, e] = 'hello';
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"
```
类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值  
```js
let {length : len} = 'hello';
len // 5
```












